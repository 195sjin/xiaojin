
# 数据结构

## 一、线性表

### 线性表的类型定义

​    线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素 不仅可以进行访问，而且可以进行插入和删除等操作。

逻辑特征：

在非空的线性表，有且仅有一个开始结点，有且仅有一个终端结点，

其余的内部节点都有且仅有一个直接前驱和一个直接后继


c里面释放空间：free( p )

​		 p是一个指针类型的变量

c++里面释放空间：delete( p )

​		p是一个指针类型的变量

### 顺序表

​		用一组**地址连续**的存储单元依次存储线性表的数据元素， 这种表示 也称作线性表的顺序存储结构或顺序映像。

其特点是，**逻辑上相邻的数据元素， 其物理次序也是相邻的。**

​		只要确定了存储线性表的起始位置， 线性表中任一数据元素都可随 机存取， 所以线性表的顺序存储结构是一种**随机存取**的存储结构。

计算顺序表中元素存储位置  LOC(ai)=LOC(a1)+(i-1)*L  ------->L表示每个元素需要占据L个存储单元

通常都用数组来描述数据结构中的顺序 存储结构。但是顺序表的长度可以变，而数组的长度不可以变，因此C语言中可用动态分配的一维数组表示线性表

```
顺序表的存储结构
#define MAXSIZE 100
typedef struct{
ElemType *elem; ／／是一个动态分配数组，存储空间的基地址
int length; ／／当前长度
}SqList; ／/顺序表的结构类型为SqList
动态分配数组的内存
L.elem=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);
```

#### 顺序表的基本操作

**顺序表的初始化**

```
Status InitList(SqList &L) {
	／／构造一个空的顺序表 L
L.elem= new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间
if (! L. elem) exit (OVERFLOW); /／存储分配失败退出
L.length=O; ／／空表长度为0
return OK; }

```

**判断线性表是否为空**

```
int isEnpty(SqList L){
if(l/length==0)return 1;
else return 0;
}
```

**取值**

根据指定的位置序号i, 获取顺序表中第i个数据元素的值。

算法的时间复杂度为0(1)。

```
Status GetElem(SqList L,int i,ElemType &e) {
if (i<1||i>L.length) return ERROR; //判断i值是否合理，若不合理,返回 ERROR
e=L.elem[i-1];            //elem[i-1] 单元存储第 i 个数据元素
return OK; 
}
```

**查找**

查找操作是根据指定的元素值e, 查找顺序表中第1个与e相等的元素。

算法的平均时间复杂度为 O(n)。

```
int LocateELem(SqList L,ElemType e) {
／／在顺序表1中查找值为e的数据元素， 返回其序号
for(i=O;i< L.length;i++) 
if(L.elem[i]==e) return i+l; ／／查找成功， 返回序号 i+l
return O; ／／查找失败， 返回 0
}
```

 **顺序表的插入**

1判断插入位置是否合法、2判断存储空间是否已满、3将后面的元素依次后移、4插入、5表长加1

算法的平均时间复杂度为 O(n)。

```
Status ListInsert(SqList &L,int i ,ElemType e) 
{//在顺序表L中第i个位置之前插入新的元素 e, i值的合法范围是 1<=i<=L.length+1 
if((i<1) || (i>L.length+1)) return ERROR; //i值不合法
if(L.length==MAXSIZE) return ERROR; ／／当前存储空间已满
for (j=L.length-1; j>=i-1; j--) 
L.elem[j+1]=L.elem[j]; ／／插入位置及之后的元素后移
L.elem[i-1]=e;／／将新元素e放入第i个位置
++L.length; ／／表长加1
return OK;
}
```

**删除**

的平均时间复杂度为O(n)。

```
Status ListDelete(SqList &L,int i) 
{//在顺序表L中删除第i个元素，i值的合法范围是 1<=i<=L.length 
if((i<1) || (i>L.length)) return ERROR; ／i值不合法
for (j=i; j <=L. length-1; j ++) 
L.elem[j-1]=1.elem[j]; ／／被删除元素之后的元素前移
--L.length; ／／表长减1
return OK; 
}
```

### 链式表

特点是：用一组**任意的存储单元**存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。

结点包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。

整个链表的存取必须从头指针开始进行，头指针指示链表中第一个结点（即第一个数据元素的存储映像，也称首元结点） 的存储位置。

单链表是非随机存取的存储结构,也称为**顺序存取**的存取结构

```
／／－－－－－ 单链表的存储结构－－－－－
typedef struct LNode {
ElemType data; ／／结点的数据域
struct LNode *next; ／/结点的指针域
}LNode,*LinkList; //LinkList 为指向结构体 LNode 的指针类型
```

>LinkList 与 LNode* , 两者本质上是等价的。通常习惯上用 LinkList 定义单链表，强调定义的是某个单链表的头指针；用 LNode *定义指向单链表中任意结点的指针变量。
>
>例如，若定义 LinkList L,  则L为单链表的头指针，若定义 LNode*p, 则p为指向单链表中某个结点的指针，用*p 代表 该结点。
>
> 注意区分指针变量和结点变量两个不同的概念
>
>若定义 LinkListp 或 LNode*p, 则p 为指向某结点的指针变量，表示该结点的地址；而*p 为对应的结点变量，表示该结 点的名称。

一般情况下，为了处理方便，在单链表的第一个结点之前附设一个结点，称之为头结点。

头结点的作用:

(1)便于首元结点的处理

(2)便于空表和非空表的统一处理

当链表不设头结点时，假设 L 为单链表的头指针，它应该指向首元结点，则当单链表为长度 n 为 0 的空表时， L 指针为空（判定空表的条件可记为：L== NULL）。

增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。若为空表，则头结点的指针域为空（判定空表的条件可记为： L ->next== NULL）

#### 单链表的基本操作

**初始化**

```
tatus InitList(LinkList &L) {
／／构造一个空的单链表L
L=new LNode; ／／生成新结点作为头结点， 用头指针L指向头结点
//或者 L=(LinkList)malloc(sizeof(LNode));
L->next=NULL; ／／头结点的指针域置空
return OK; 
}
```

**判断链表是否为空**

```
int ListEmpty(LinkList L){
if(L->next)//非空
return 0;
else
return 1;
}
```

**求单链表的表长**

```
int ListLength(LinkList){//返回L中数据元素个数
LinkList p;
p->next;//p指向第一个结点
i=0;
while(p){//遍历单链表，统计结点数
i++;
p=p->next;
}
return i;
}
```

**取值**

算法的平均时间复杂度为O(n)。

```
Status GetElem(LinkList L,int i,ElemType &e){
//获取线性表L中某个数据元素的内容，通过变量e返回
p=L->next;j=1;//初始化p指向首元结点，计数器j初值赋为1
while(p&&j<i){//向后扫描，直到p指向第i个元素或p为空
p=p->next;++j;
}
if(!p||j>i)return ERROR;//i值不合法 i>n或i<=0
e=p->data;//取第i个元素
return OK;
}
```

**按值查找**

平均时间复杂度为 O(n)。

```
LNode *LocateELem(LinkList L, Elemtype e){ 
／／在带头结点的单链表L中查找值为e的元素
p=L->next; ／／初始化，p指向首元结点
while(p && p->data!=e) ／／顺链域向后扫描，直到p为空或p所指结点的数据域等于e
p=p->next; //p指向下一个结点
return p; ／／查找成功返回值为e的结点地址p, 查找失败p为NULL
}
```

**单链表的插入**

算法的时间复杂度为0(n)。

```
Status Listinsert(LinkList &L,int i,ElemType e){ 
／／在带头结点的单链表L中第i个位置插入值为e的新结点
p=L;j=O; 
while (p && (j<i-1)) 
{p=p->next;++j;} ／／查找第i-1个结点，p指向该结点
if (!p || j>i-1) return ERROR; //i>n+l或者i<1
s=new LNode; 
s->data= e; 
s->next=p->next;／／将结点 *s的指针域指向结点 a,
p->next=s; ／／将结点*p的指针域指向结点*s
return OK;
}
```

> 和顺序表一样，如果表中有 n 个结点 ，则插入操作中合法的插入位置有 n+l 个，即 1<=i<=n+l 。当 i =n+l 时，新结点则插在链表尾部。

**单链表的删除**

算法的时间复杂度为0(n)。

```
Status ListDelete(LinkList &L,int i) {
／／在带头结点的单链表L中，删除第i个元素
p=L;j=O; 
while ((p->next) && (j<i-1)) ／／查找第i-1个结点，p指向该结点
{p=p->next; ++j;} 
if (! (p->next) || (j>i-1)) return ERROR;//当i>n或i<1时，删除位置不合理
q=p->next;//临时保存被删结点的地址以备释放
p->next=q->next;//改变删除结点前驱结点的指针域
delete q;  //释放删除结点的空间
return OK;
}
```

> 删除算法中的循环条件(p->next&&j<i-1)和插入算法中的循环条件(p&&(j<i—1))是有所
> 区别的。
>
> 因为插入操作中合法的插入位置有n+l个，而删除操作中合法的删除位置只有n
> 个，如果使用与插入操作相同的循环条件，则会出现引用空指针的情况，使删除操作失败。

**创建单链表**

**（1）前插法创建**

算法的时间复杂度为0(n)

```
void CreateList_H(LinkList &L,int n) 
{//逆位序输入n个元素的值，建立带表头结点的单链表L
L=new LNode;
L->next=NULL; ／／先建立一个带头结点的空链表
for(i=O;i<n;++i) {
p=new LNode; ／／生成新结点*p
cin>>p->data; ／／输入元素值赋给新结点*p的数据域
p->next=L->next;
L->next=p; ／／将新结点*p插人到头结点之后
}
}
```

**(2)后插法创建**

算法的时间复杂度为0(n)

```
void CreateList_R(LinkList &L,int n) {
／／正位序输人n个元素的值， 建立带表头结点的单链表L
L=new LNode; 
L->next=NULL; ／／先建立一个带头结点的空链表
r=L; ／／尾指针r指向头结点
for(i=O;i<n;++i) {
p=new LNode; ／／生成新结点
cin>>p->data; ／／输人元素值赋给新结点*p的数据域
p->next=NULL;
r->next=p; ／／将新结点*p插人尾结点*r之后
r=p; //r指向新的尾结点*p
}
}
```

#### 循环链表

其特点是表中最后一个结点 的指针域指向头结点，整个链表形成一个环，即头尾相连，形成一个环。从表中任何一个结点出发均可找到表中其他结点。

判别当前指针p是否 指向表尾结点的终止条件不同。

在单链表中，判别条件为p!=NULL或p->next!=NULL, 而循环 单链表的判别条件为p!=L或p->next!=L

**带尾指针的循环链表的合并**

```
LinkList Connect(LinkList Ta,LinkList Tb){
p->Ta->next;//p存Ta表头结点
Ta->next=Tb->next->next;//Tb表头结点连接Ta表尾
delete Tb->next;//释放表头结点
Tb->next=p;//修改指针
return Tb;
}
```

#### 双向链表

双向链表的结点中有两个指针域，一个指向直接后继， 另一个指向直接前驱。

在双向链表中， 若 d为指向表中某一结点的指针，则d->next->prior = d->prior->next = d 

**双向链表的插入**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesezksjm.png)

```
Status Listinsert_DuL(DuLinkList &L,int i,ElemType e) 
{//在带头结点的双向链表L中第i个位置之前插入元素e
if (!(p=GetElem_DuL (L, i))) ／／在L中确定第i个元素的位置指针p
return ERROR; //p为 NULL 时，第i个元素不存在
s=new DuLNode; ／／生成新结点*s
s->data=e; ／／将结点*s数据域置为e
s->prior=p->prior; ／／将结点*s插入L,如①
p->prior->next=s; //对应②
s->next=p; //对应③
p->prior=s; //对应④
return OK; 
}
```

**双链表的删除**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesezna2i.png)

```
Status ListDelete_DuL(DuLinkList &L,int i) 
{//删除带头结点的双向链表L中的第i个元素
if (! (p=GetElem_DuL (L, i))) ／／在L 中确定第 i个元素的位置指针p
return ERROR; //p为 NULL 时，第i个元素不存在
p->prior->next=p->next; ／／修改被删结点的前驱结点的后继指针，对应①
p->next->prior=p->prior; ／／修改被删结点的后继结点的前驱指针，对应图②
delete p; ／／释放被删结点的空间
return OK; 
}
```

**单链表、循环链表和双向链表的时间效率比较**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesf5j8nv.png)

### 顺序表与链表的比较

![image-20221217192736335](https://raw.githubusercontent.com/195sjin/myBed/master/imagesimage-20221217192736335.png)

### 线性表的合并

 LocateElem 的执行时间和表长 m 成正比,时间复杂度为 O(m x n)。

```
void MergeList(List &LA,List LB) 
{/ /将所有在线性表 LB中但不在LA中的数据元素插入到LA中
m=ListLength(LA); n=ListLength(LB); //求线性表的长度
for(i=l;i<=n;i++)
{
GetElem(LB,i,e); ／／取 LB中第i个数据元素赋给 e
if (! LocateElem (LA, e)) //LA中不存在和 e 相同的数据元素
Listinsert(LA,++m,e); ／／将 e 插在LA的最后
}
}
```

### 有序表的合并

若线性表中的数据元素相互之 间可以比较， 并且数据元素在线性表中依值非递减或非递增有 序排列， 则称该线性表为有序表

**用顺序表实现**

如果两个表长分别记为m和n，算法的时间复杂度为O(m+ n)

```
void MergeList_Sq(SqList LA,SqList LB,SqList &LC) 
{// 已知顺序有序表LA和LB的元素按值非递减排列
／／归并LA和LB得到新的顺序有序表LC, LC的元素也按值非递减排列
LC.length=LA.length+LB.length; //新表长度为待合并两表的长度之和
LC.elern=new ElemType[LC.length]; //为合并后的新表分配一个数组空间
pc=LC.elem; ／／指针pc 指向新表的第一个元素
pa=LA.elem; pb=LB.elem; ／／指针pa 和pb 的初值分别指向两个表的第一个元素
pa_last=LA.elem+LA.length-1; ／／指针pa_last指向LA的最后一个元素
pb_last=LB.elem+LB.length-1;  //指针pb_last指向LB的最后一个元素
while ((pa<=pa_last) && (pb<=pb_last)) / /LA和LB均未到达表尾
{
if(*pa< =*pb ) *pc++=*pa++; ／／依次 ＂摘取“ 两表中值较小的结点插人到LC的最后
else *pc++=*pb++; 
}
while (pa<=pa_last) *pc++=*pa++; //LB已到达表尾，依次将LA的剩余元素插人LC的最后
while (pb<=pb_las t) *pc++=*pb++; //LA已到达表尾，依次将LB的剩余元素插入LC的最后
}
```

**用链表实现**

如果两个表长分别记为m和n，算法的时间复杂度为O(m+ n)

```
void MergeList_L(LinkList &LA,LinkList &LB,LinkList &LC) {
／／已知单链表 LA和LB的元素按值非递减排列
//归并LA 和 LB得到新的单链表 LC, LC的元素也按值非递减排列
pa=LA->next;pb=LB->next; //pa 和 pb的初值分别指向两个表的第一个结点
LC=LA; ／／用LA的头结点作为LC的头结点
pc=LC; //pc的初值指向LC的头结点
while(pa&&pb) 
{//LA 和 LB均未到达表尾，依次 “摘取”两表中值较小的结点插人到LC的最后
if(pa->data<=pb->data) //'摘取"pa所指结点
{
pc->next=pa; ／／将pa所指结点链接到pc所指结点之后
pc=pa; //pc指向pa
pa=pa->next; //pa指向下一结点
}
else // "摘取"pb所指结点
{
pc->next=pb; ／／将pb所指结点链接到pc所指结点之后
pc=pb; //pc指向pb
pb=pb->next; //pb指向下一结点
}
}//while 
pc->next=pa?pa:pb; ／／将非空表的剩余段插入到pc所指结点之后
delete LB; ／／释放LB的头结点
}
```

## 二、栈和队列

### 栈

#### 栈的定义和特点

栈是限定仅在表尾进行插入或删除操作的线性表。表尾端称为栈顶；表头端称为栈底；不含元素的空表称为空栈。

栈又称为**后进先出**的线性表。

#### 顺序栈

```
/／－－－－－ 顺序栈的存储结构－ －－－－
#define MAXSIZE 100 ／／顺序栈存储空间的初始分配址
typedef struct 
{
SElemType *base; ／／栈底指针
SElernType *top; ／／栈顶指针
int stacksize; ／／栈可用的最大容量
}SqStack; 
```

> 栈底指针 base 始终指向栈底的位置， 若 base 的值为NULL, 则表明栈结构不存在。
>
> top 为栈顶指针， 其初值指向栈底。 每当 插入新的栈顶元素时， 指针 top 增1; 删除栈顶元素时， 指针 top 减1。
>
> 栈空时， top 和 base 的值相等， 都指向栈底。base==top
>
> 栈满：top-base=stacksize
>
> 栈长：S.top-S.base
>
> 栈非空时， top 始终指向栈顶元素的上一个 位置。

**初始化**

```
Status InitStack(SqStack &S) {
／／构造一个空栈s
S.base=new SElemType[MAXSIZE]; ／／为顺序栈动态分配一个最大容量为 MAXSIZE 的数组空间
	//S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType))
if (! S. base) exit (OVERFLOW) ; ／／存储分配失败
S.top=S.base;				//top 初始为 base, 空栈
S.stacksize=MAXSIZE; 		//stacksize 置为栈的最大容量 MAXSIZE
return OK;
}
```

**入栈**

```
Status Push (SqStack &S, SElemType e) 
{//插入元素e为新的栈顶元素
if(S.top-S.base==S.stacksize) return ERROR; //栈满
*S.top=e;S.top++;//*S.top++=e; //元素 e 压入栈顶， 栈顶指针加 1
return OK
```

**出栈**

```
Status Pop(SqStack &S,SElemType &e) 
{//若栈不为空，删除s的栈顶元素， 用 e 返回其值
if(S.top==S.base) return ERROR; //等价于if(StackEmpty(S))／／栈空
--S.top;e=*S.top;//e=*--S.top;／／栈顶指针减 1, 将栈顶元素赋给e
return OK; 


```

**取栈顶元素**

```
SElemType GetTop(SqStack S) 
｛／／返回 s 的栈顶元素， 不修改栈顶指针
if(S.top! =S.base) ／／栈非空
return *(S.top-1); ／／返回栈顶元素的值，栈顶指针不变
}
```

#### 链栈

以链表的头部作 为栈顶是最方便的， 而且没必要像单链表那样为了操作方便附加一 个头结点。

```
／／－－－－－ 链栈的存储结构－－－－－
typedef struct StackNode 
{
ElemType data; 
struct StackNode *next; 
} StackNode,*LinkStack;
```

**初始化**

```
Status InitStack(LinkStack &S) 
{//构造一个空栈 s, 栈顶指针置空
S=NULL; 
return OK; 
}
```

**入栈**

```
Status Push(LinkStack &S, SElemType e) 
｛／／在栈顶插入元素e
p=new StackNode; ／／生成新结点
p->data=e; ／／将新结点数据域置为e
p->next=S; ／／将新结点插人栈顶
S=p; ／／修改栈顶指针为p
return OK; 
}
```

**出栈**

```
Status Pop(LinkStack &S,SElemType &e) {
／／删除 s 的栈顶元素，用 e 返回其值
if(S==NULL) return ERROR; ／／栈空
e=S->data; ／／将栈顶元素赋给 e
p=S; ／／用 p 临时保存栈顶元素空间， 以备释放
S=S->next; ／／修改栈顶指针
delete p; ／／释放原栈顶元素的空间
return OK; 
}
```

**取栈顶元素**

```
SElemType GetTop(LinkStack S) {
／／返回 s 的栈顶元素， 不修改栈顶指针
if(S! =NULL) //栈非空
return S->data; ／／返回栈顶元素的值，栈顶指针不变
}

```

#### 栈和递归

**递归的优缺点**

优点：结构清晰，程序易读

缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。

**递归   --------->   非递归**

方法1：尾递归、单向递归  ------> 循环结构

方法2：自用栈模拟系统的运行时栈

尾递归------->循环结构

```
long Fact(long n){
if(n==0)return 1;
else return n*Fact(n-1);
}
```

```
long Fact(long n){
t=1;
for(i=1;i<=n;i++) t=t*i;
return t;
}
```

### 队列

#### 队列的定义和特点

队列只允许在表 的一端进行插入，而在另一端删除元素。允许插入的一端称为队尾；允许 删除的一端则称为队头。

头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置

队列是一种**先进先出**的线性表。

#### 顺序队列

```
／／ －－－－－ 队列的顺序存储结构－－－－－
#define MAXQSIZE 100 ／／队列可能达到的最大长度
typedef struct 
{ 
QElemType *base; ／／存储空间的基地址
int front; //头指针
int rear; ／／尾指针
} SqQueue; 
```

每当插入 新的队列尾元素时，尾指针 rear增1; 每当删除队列头元素时， 头指针 front增1。

**如何区别循环队列是队空还是队满**

少用一个元素空间， 即队列空间大小为m时，有m-1个元素就认为是队满。

当头、 尾指针的值相同时， 则认为队空。

当尾指针在循环意义上加1后是等 于头指针， 则认为队满。

> 队空的条件： Q.front = Q.rear 
>
> 队满的条件： (Q .rear+ 1)%MAXQSIZE = Q.front

**顺序队列的初始化**

```
Status InitQueue (SqQueue &Q) 
{//构造一个空队列Q
Q.base=new QElemType[MAXQSIZE]／／为队列分配一个最大容扯为 MAXQSIZE 的数组空间
if(!Q.base) exit(OVERFLOW);／／存储分配失败
Q.front=Q.rear=O;//头指针和尾指针置为零， 队列为空
return OK;
}
```

**求循环队列长度**

非循环队列，尾指针和头指针的差值便是队列长度。

对于循环队列，差值可能为负数， 所以需要将差值加上MAXQSIZE, 然后与MAXQSIZE求余

```
int QueueLength(SqQueue Q) 
{／／返回Q的元素个数， 即队列的长度
return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE; 
}
```

**循环队列入队**

```
Status EnQueue (SqQueue &Q, QElemType e) 
{//插入元素 e 为 Q 的新的队尾元素
if ((Q.rear+l) %MAXQSIZE==Q. fron)／／尾指针在循环意义上加1后等于头指针， 表明队满
return ERROR; 
Q.base[Q.rear]=e;／／新元素插入队尾
Q.rear=(Q.rear+l)%MAXQSIZE;／／队尾指针加1
return OK; 
}
```

**循环队列出队**

```
Status DeQueue (SqQueue &Q, QElemType &e) 
{／／删除Q的队头元素， 用 e 返回其值
if(Q.front==Q. rear) return ERROR; / /队空
e=Q.base[Q.front]; //保存队头元素
Q.front=(Q.front+l)%MAXQSIZE; //队头指针加1
return OK;
}
```

**取循环队列的队头元素**

```
SElemType GetHead(SqQueue Q) 
{／／返回Q的队头元素，不修改队头指针
if(Q. front! =Q. rear) ／／队列非空
return Q.base[Q.front]; ／／返回队头元素的值，队头指针不变
}
```

#### 链队列

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesqwxyyp.png)

为了操作方便起见，给链队添加一个头结点， 并令头指针始 终指向头结点。

```
／／－－－－－ 队列的链式存储结构－－－－－
typedef struct QNode
{
	QElemType data; 
	struct QNode *next; 
}QNode, *QueuePtr; 

typedef struct
{ 
QueuePtr front; ／／队头指针
QueuePtr rear; ／／队尾指针
 } LinkQueue; 


```

**初始化**

```
Status InitQueue (LinkQueue &Q) 
{／／构造一个空队列 Q
Q.front=Q.rear=new QNode;／／生成新结点作为头结点，队头和队尾指针指向此结点
Q.front->next=NULL;／／头结点的指针域置空
return OK;
}
```

**链队列的入队**

```
Status EnQueue (LinkQueue &Q, QElemType e) 
{//插入元素e为Q的新的队尾元素
p=new QNode; //为入队元素分配结点空间，用指针p指向
p->data=e; //将新结点数据域置为e
p->next=NULL; Q.rear->next=p; //将新结点插入到队尾
Q.rear=p; //修改队尾指针
return OK; 
}
```

**链队的出队**

```
Status DeQueue(LinkQueue &Q,QElemType &e) 
{／／删除Q的队头元素， 用e返回其值
if(Q.front==Q.rear) return ERROR; ／／若队列空， 则返回 ERROR
p=Q.front->next; //p指向队头元素
e=p->data; //e保存队头元素的值
Q.front->next=p->next;／／修改头指针
if(Q.rear==p) Q.rear=Q.front; ／／最后一个元素被删， 队尾指针指向头结点
delete p; ／／释放原队头元素的空间
return OK; 
}
```

**取链队的队头元素**

```
SElemType GetHead(LinkQueue Q) 
{//返回Q的队头元素， 不修改队头指针
if(Q.front!=Q.rear) ／／队列非空
return Q.front->next->data; ／／返回队头元素的值，队头指针不变
}
```



## 三、串、数组和广义表

### 串

#### 串的类型定义、存储结构

串(string)(或字符串）是由零个或多个字符组成的有限序列

**串的顺序存储**

算法描述当中所用到的顺序存储的字符串都是从下标为1的数组分量开始存储的， 下标为0的分量闲置不用

```
／／－－－－－ 串的定长顺序存储结构－ － －－－
#define MAXLEN 255 ／／串的最大长度
typedef struct { 
char ch[MAXLEN+l]; ／／存储串的一维数组
int length; ／／串的当前长度
} SString; 
```

在C语言中， 存在一个称之为 ＂堆" (Heap)的自由存储区， 可以 为每个新产生的串**动态分配**一块实际串长所需的存储空间， 若分配成功， 则返回一个指向起始 地址的指针， 作为串的基址， 同时为了以后处理方便， 约定串长也作为存储结构的一部分。

```
／／－－－－－ 串的堆式顺序存储结构－－－－ －
typedef struct{ 
char *ch; ／／若是非空串， 则按串长分配存储区， 否则 ch 为 NULL
int length; ／／串的当前长度
}HString; 
```

**串的链式存储**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesr4ql7l.png)

当以链表存储串值时，除头指针外， 还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。

```
／／－－－－－ 串的链式存储结构－ － －－－
#define CHUNKSIZE 80 //可由用户定义的块大小
typedef struct Chunk{ 
char ch [CHUNKSIZE];
struct Chunk *next; 
} Chunk; 

typedef struct{ 
Chunk *head,*tail; ／／串的头和尾指针
int length; ／／串的当前长度
} LString; 
```

#### 串的算法------BF算法

主串的长度为n, 子串的长度为m

最好情况下的平均时间复杂度是 O(n + m)

最坏情况下的平均时间复杂度是 O(n x m)



串的模式匹配设有两个字符串S和T, 设S为主串，也称正文串；设T为子串，也称为模式。

在主串S中查找与模式T相匹配的子串，如果匹配成功， 确定相匹配的子串中的**第一个**字符在主 串S中出现的位置。

思路：从主串的每一个字符开始依次与子串的字符进行匹配。

```
int Index_BF(SString S,SString T,int pos)
{／／返回模式T在主串s中第pos个字符开始第一次出现的位置。若不存在， 则返回值为0
／／其中，T非空，1<=pos<=s.length
i=pos; j=l; //初始化
while (i < =S. length && j < =T. length) / /两个串均未比较到串尾
{
if(S[i].ch==T[j] .ch) {++i;++j;} //主串和子串依次匹配下一个字符
else{i=i-j+2;j=l;} //主串子串指针回溯重新开始下一次匹配
}
if (j > T. length) return i-T. length; //返回匹配的第一个字符的下标
else return O; //匹配失败
}
```

> 在指针回溯的时候，子串的直接回溯回1，主串的需要回溯到i-j+2
>
> 可以看成是i-j+1+1 ;  i-j+i是i回退到最开始的位置，再+1是因为要从下一个开始
>
> 成功返回的第一个字符的下标是 i-T.length

#### 串的算法------KMP算法

可以在 O(n + m)的时间数量级上完成串的模式匹配操作

不需回溯 i 指针;  j 需要回到的位置为next[j];

next[j]表明当模式中第j 个字符与主串中相应字符 ＂失配” 时，在模 式中需重新和主串中该字符进行比较的字符的位置

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessd3hvt.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessgb0v8.png)

**next值的计算**

在这个例子中，j=15的时候是d,从头开始的有6个元素与j前面的6个元素相等，所以k-1=6---->k=7

```
int Index_KMP(SString S,SString T,int pos){
//利用模式串 T 的 next 函数求 T 在主串 S 中第 pos 个字符之后的位置
／／其中，T非空， 1<=pos<=s.length 
i=pos;j=1; 
while (i < =S.length && j < =S.length)／／两个串均未比较到串尾
{ 
if ( j == 0 || s [ i ] ==T [ j ] ){ ++ i ; ++ j ; } ／／继续比较后继字符
else j=next[j]; ／／模式串向右移动
if (j > T [0]) return i-T [0] ; ／／匹配成功
else return 0; ／／匹配失败
}
}
```

```
void get_next(SString T,int next[]) 
{//求模式串 T的 next 函数值并存入数组 next
i=1;next[1]=0;j=0; 
while (i <=T.length) 
{
if(j==0 || T[i]==T[j]) {++i;++j;next[i]=j; } 
else j=next[j];
}
}
```

**nextval的计算**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesu8emdv.png)

next值是几，就和第几位进行比较，若相同，则与该位的next值所示的新的元素进行比较，若不同，则nextval值为前一个元素的next值，若不同，则nextval的值就为自己的next值

```
void get_nextval(SString T, int nextval[]) 
{／／求模式串 T 的 next 函数修正值并存入数组 nextval
i=l;nextval[1] =0; j=0; 
while(i<T.length) 
{
if (j==0 || T [i] ==T [j])
	{
		++i;++j; 
		if(T[i] !=T[j]) nextval[i]=j; 
		else nextval [i] =nextval [ j] ;
	}
else j=nextval[j];
}
}
```

### 数组

#### 数组的定义及特点

数组是由类型相同的数据元素构成的有序集合。

特点：数组一旦被定义， 它的维数和维界就不再改变。除了结构的初始化和销毁之外， 数组 只有存取元素和修改元素值的操作。

一维数组可以看成是一个线性表，二维数组可以看成数据元素是线性表的线性表。一个 n 维数组类型可以定义为其数据元素为 n-1维数组类型的一维数组类型。

#### 数组的顺序存储

一维数组：

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesfpbrsq.png)

二维数组：

以行序为主序

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesftdtxk.png)

三维数组：

m1:表示在第几页、m2:表示在第几行、 m3：表示在第几列

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesgjzj6w.png)

#### 特殊矩阵压缩存储（对称、三角、对角、稀疏）

为多个相同的非零元素只分配一个存储空间；对零元素不分配空间

**对称矩阵**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesh2naoa.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesh6ahn1.png)

**三角矩阵**

三角矩阵有上三角矩阵和下三角矩阵两种。

上三角矩阵是指矩阵下三角（不包括对角线）中的元均为常数c或零的n阶矩阵， 下三角矩阵与之相反。

除了和对称矩阵一样， 只存储其上 （下）兰角中的元素之外， 再加一个存储常数c的存储 空间即可。

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesh9p98w.png)

下三角矩阵

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesh9v7kk.png)

**对角矩阵**

所有的非零元都集中在以主对角线为中心的带状区域中，即除了主对角线上 和直接在对角线上、下方若干条对角线上的元之外，所有其他的元皆为零

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageshckmix.png)

**稀疏矩阵**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageshflqn7.png)

三元组顺序表的优点：非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。

缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始进行查找。

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesi73bbv.png)

### 广义表

#### 广义表的性质

广义表是线性表的推广，也称为列表，是n个元素的有限序列，其中每一个ai或者是原子，或者是一个广义表。

表头：第一个元素a1就是表头

表尾：除表头外的其他元素组成的表，表尾不是最后一个元素，而是一个子表

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesid085l.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesifj72f.png)

(1·) 取表头 GetHead(LS): 取出的表头为非空广义表的第一个元素，它可以是一个单原子，也 可以是一个子表

(2) 取表尾 GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是 一个广义表。

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesiicrmf.png)

## 四、树和二叉树

### 树的定义与基本术语

树是n个结点的有限集，有且仅有一个根结点。

* 结点：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支
* 结点的度：结点拥有的子树数称为结点的度
* 树的度：树的度是树内各结点度的最大值
* 叶子： 度为 0 的结点称为叶子或终端结点
* 非终端结点：度不为 0 的结点称为非终端结点或分支结点
* 双亲和孩子：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲
* 兄弟：同一个双亲的孩子之间互称兄弟
* 祖先：从根到该结点所经分支上的所有结点
* 子孙：以某结点为根的子树中的任一结点都称为该结点的子孙
* 层次：结点的层次从根开始定义起，根为 第一层，根的孩子为第二层。树中任一结点的 层次等千其双亲结点的层次加 1。
* 堂兄弟：双亲在同 一层的结点互为堂兄弟
* 树的深度：树中结点的最大层次称为树的深度或高度
* 有序树和无序树：如果将树中结点的各子树看成从左至右是有次序的（即不能互换）， 则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的 称为最后一个孩子
* 森林：是 m (m>0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即 为森林

### 二叉树的定义

二叉树的递归定义表明二叉树或为空或是由一个根结点加上两棵分别称为左子树和右子树 的、互不相交的二叉树组成。

二叉树每个结点至多只有两棵子树

二叉树的子树有左右之分，其次序不能任意颠倒

二叉树就算只有一个结点，也要指明是左子树还是右子树，而树就不需要区分左右次序。

### 二叉树的性质

**性质1** 	在二叉树的 第i层上至多有2^(i-1) 个结点（i>=1)，至少有1个结点。

**性质2** 	深度为K的 二叉树至多有 2^k -1 个结点 (k>=1)，至少有k个结点。

**性质3** 	对任何一棵二叉树T, 如果其终端结点数为n0，度为2的结点数为n2,则n0 = n2+1

**满二叉树**	

深度为 K且含有2 ^k-1个结点的二叉树

特点：每层都满、叶子结点全在最底层

编号规则：从根结点开始，从上而下、从左而右

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesprv50z.png)

**完全二叉树**

深度为K的， 有n个结点的二叉树， 当且仅当其每一个结点都与深度为K的满 二叉树中编号从1至n的结点一一对应时， 称之为完全二叉树

特点：叶子结点只可能在层次最大的两层上出现、对任一结点， 若右子树最大层次为l, 则其左子树最大层次必 为 l 或 l+ 1。

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesqj6bu0.png)

**性质 4** 	具有 n 个结点的完全二叉树的深度为llog2n|+ 1 。

**性质 5** 	描述双亲结点编号与孩子结点编号之间的关系

如果对一棵有 n个结点的完全二叉树（其深度为Llog2n」+ 1） 的结点按层序编号（从 第 1 层到第llog2n」+ 1 层， 每层从左到右）， 则对任一结点i（1<=i<=n）, 有

(1)如果i = 1, 则结点l是二叉树的根，无双亲；如果i> 1, 则其双亲PARENT(i )是结 点Li/2」

( 2 )如果2i>n, 则结点i无左孩子（结点i为叶子结点）；否则其左孩子LCHILD(i)是结点 2i

(3)如果2i+1>n, 则结点i无右孩子；否则其右孩子RCHILD(i )是结点2i+l。

### 二叉树的存储结构

**顺序存储结构**

```
//-----二叉树的顺序存储表示－－－－－
#define MAXTSIZE 100 ／／二叉树的最大结点数
typedef TElemType SqBiTree[MAXTSIZE]; //0 号单元存储根结点
SqBiTree bt; 
```

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesqqsogu.png)

**链式存储结构**

表示二叉树的链表 中的结点至少包含 3 个域：数据域和左、 右指针域，有时，为了便于找到结 点的双亲，还可在结点结构中增加一个指向其双亲结点的指针域，链表的头指 针指向二叉树的根结点

在含有 n个结点的二叉链表中有 n+l 个空链域

```
//- - - - -二叉树的二叉链表存储表示－ －－－－
typedef struct BiTNode{ 
TElemType data; ／／结点数据域
struct BiTNode *lchild,*rchild; ／／左右孩子指针
} BiTNode,*BiTree; 
```

### 遍历二叉树

三种遍历算法的时间效率是O(n)、空间效率是O(n)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesqw9gjd.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesqy2cz0.png)

**由遍历序列确定二叉树**

由二叉树的**先序**序列和**中序**序列，或由 其**后序**序列和**中序**序列均能唯一地**确定一棵二叉树。**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesr56xqm.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesr68fg2.png)

#### 先序遍历算法

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesr8ve4k.png)

#### 中序遍历算法

**递归算法**

![](https://raw.githubusercontent.com/195sjin/myBed/master/images7l7nagi.png)

**非递归算法**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagess6lnsj.png)

#### 后序遍历算法

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesrbsfpk.png)

#### 层次遍历算法

对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点，每个节点仅仅访问一次。

根结点先进队，然后左孩子进队、右孩子进队、左孩子的左孩子进队、左孩子的右孩子进队........

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagess9o6c6.png)

### 遍历算法的应用

#### 二叉树的建立

![](https://raw.githubusercontent.com/195sjin/myBed/master/images7wb0v4y.png)

#### 复制二叉树

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesskw65x.png)

#### 计算二叉树的深度

二叉树的深度为树中结点的最大层次， 二叉树的深度为左右子树深度的较大者加1。

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessmod0v.png)

#### 计算二叉树结点总数

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessoh8f8.png)

### 线索二叉树

这里的”前驱“、”后继“指的是在遍历序列中的顺序

如：中序遍历为CBEGDFA,   A的前驱为F。B的后继为E

如果某个结点的**左孩子为空**，则将空的左孩子指针域改为**指向其前驱**；

如果某个结点的**右孩子为空**，则将空的右孩子指针域改为**指向其后继**；

![](https://raw.githubusercontent.com/195sjin/myBed/master/images81byhx7.png)

```
//- - - - -二叉树的二叉线索存储表示－ －－－－
typedef struct BiThrNode 
{ 
TElemType data; 
struct BiThrNode *lchild,*rchild; //左右孩子指针
int LTag, RTag; //左右标志
} BiThrNode,*BiThrTree;
```

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagest0jg0v.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagest0mzyn.png)

为了避免遍历结果中第一个元素它没有前驱，所以它的指向前驱的指针悬空，最后一个元素没有后继，所以它的指向后继的指针悬空，因此增设了一个头结点

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagestsjcxr.png)

### 树的存储结构

#### 双亲表示法

以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置

利用了每个结点（除根以外）只有唯一的双亲的性质。

在这种存储结构下， **求结点的双亲十分方便**，也很容易求树的根，但**求结点的孩子时不方便**需要遍历整个结构

![](https://raw.githubusercontent.com/195sjin/myBed/master/images8awdrah.png)

#### 孩子链表

语言叙述感觉有点别扭，一个图解决一切！

用孩子链表查找孩子快，查找双亲慢

用带双亲的孩子链表查找孩子快，查找双亲也快

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagestz2wha.png)

#### 孩子兄弟法

又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。

链表中结点的两个 链域分别指向该结点的第一个孩子结点和下一个兄弟结点

```
//- - - - - -树的二叉链表（孩子－兄弟）存储表示－－－－－
typedef struct CSNode{
ElemType data; 
struct CSNode *firstchild, *nextsibling; 
} CSNode,*CSTree;
```

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesu1xyks.png)

### 树与二叉树的转换

#### 树转化为二叉树

1  加线：在兄弟之间加一连线

2  抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系

3  旋转：以树的根结点为轴心，将整树顺时针旋转45°

**树变二叉树:兄弟相连留长子**

#### 二叉树转化为树

1  加线：p是双亲的左孩子，则找到p的右孩子、右孩子的右孩子......沿分支找到所有的右孩子，都与p的双亲用线相连

2  抹线：抹掉原二叉树中双亲与右孩子之间的连线

3  调整：将结点按层次排列，形成树结构

**二叉树变树：左孩右右连双亲，去掉原来右孩线**

### 森林与二叉树的转换

#### 森林转化为二叉树

1、将各棵树分别转换成二叉树

2、将每棵树的根结点用线相连

3、以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构

**森林变二叉树：树变二叉根相连**

#### 二叉树转换为森林

1  抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树

2  还原：将孤立的二叉树还原为树

**二叉树变森林：去掉全部右孩线，孤立二叉再还原**

### 树和森林的遍历

#### 树的遍历

一种是**先根**遍历，即先访问树的根结点，然后依次先根遍历根的每棵子树；

一种是**后根**遍历，即先依次后根遍历每 棵子树，然后访问根结点。

一种是**层次**遍历，即自上而下，自左而右访问树的每一个结点。

#### 森林的遍历

把森林看作三部分

1、森林中第一棵树的根结点

2、森林中第一棵树的子树森林

3、森林中其它树构成的森林

**先序遍历**：1、2、3；即依次对森林中的每一棵树进行先根遍历

**中序遍历**：2、1、3；即依次从左到右对森林中的每一棵树进行后序遍历

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesf1ahqs.png)

### 哈夫曼树

哈夫曼(Huffman)树又称最优二叉树，是一类**带权路径长度最短的树**，又称最优二叉树。

路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径

路径长度：路径上的分支数目称作路径长度

树的路径长度：从树根到每一结点的路径**长度之和**。

权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述

结点的带权路径长度：从该结点到树根之间的**路径长度**与结点上**权**的**乘积**。

树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和

**特点：**

满二叉树不一定是哈夫曼树、哈夫曼树中权越大的叶子结点离根越近、具有相同带权结点的哈夫曼树不唯一

#### 哈夫曼树的构造算法

**贪心算法**：构造哈夫曼树时首先选择权值小的叶子结点

**口诀：**

1、**构造森林全是根**（把给出的权值全部当做根结点）

2、**选用两小造新树**（选出两个权值最小的，一个做左子树，一个为右子树，双亲结点的权值为它们权值之和，构造这样的二叉树）

3、**删除两小添新人**（把刚才的两个最小的结点删除，把它俩的双亲结点添加）

4、**重复2、3剩单根**

因此哈夫曼树的结点2的度为0或2，没有度为1的结点

包含n个叶子结点的哈夫曼树中共有2n-1个结点（包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新节点）

#### 哈夫曼树的存储结构

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesfn8yr8.png)

#### 构造哈夫曼树算法的实现

![image-20221217193733683](https://raw.githubusercontent.com/195sjin/myBed/master/imagesimage-20221217193733683.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesfq8dyw.png)

### 哈夫曼编码

在哈夫曼树中约定左分支标记为 0, 右分支标记为 1,则根结点到每个叶子结点路径上的 0、 1序列即为相应字符的编码。

**前缀编码**：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串）， 则称编码是前缀编码

**哈夫曼编码**：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支 赋予0, 右分支 赋予1'则从根到每个叶子的路径上，各分支 的赋值分别构成一个二进制串， 该二进制串就称为 哈夫曼编码

**性质**

**1、哈夫曼编码是前缀编码**

没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其他叶结点编码的前缀

每个字符都为叶子结点

**2、哈夫曼编码是最优前缀编码**

哈夫曼树带权路径长度最短，故字符编码的总长最短

#### 哈夫曼编码的算法

依次以叶子为出发点，向上回溯至根结 点为止。 回溯时走左分支则生成代码 0, 走右分支则生成代码l

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesgtibb2.png)

## 五、图

### 图的基本概念和术语

图(Graph) G由两个集合V和E组成，记为G=(V,E）

V是顶点的有穷**非空**集合

E是V中顶点偶对的有穷集合

**图可以只有顶点没有边**

**有向图**中，顶点对<x,y>是有序的，它称为从顶点 x到顶点 y的一条有向边，x是有向边的始点，y是有向边的终点。或 x为弧尾， y为弧头。

**无向图**中，顶点对 ( x, y)是无序的，它称为顶点x与顶点y相关联的一条边。

**完全图**：任意两个点都有一条边相连，若有n个顶点就有n(n-1)/2条边，则为无向完全图；若有n(n-1)条弧，则称有向完全图。

**稀疏图和稠密图**：有很少条边或弧（如 e<nlogn)的图称为稀疏图， 反之称为稠密图

**权和网**：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。带权的图通常称为网。

 **度、入度和出度**：顶知的度是指和v相关联的边的数目，记为 TD(v);入度是以顶点v为头的弧的数目，记 为ID(v); 出度是以顶点 v 为尾的弧的数目，记为OD(v);顶点 v 的度为 TD(v) = ID(v) + OD(v)。

**当有向图中仅有一个顶点的入度为0，其余顶点的入度均为1，此时是一棵有向树**

**路径**：接续的边构成的顶点序列。

**路径长度**：路径上边或弧的数目/权值之和

**回路（环**）：第一个顶点和最后一个顶点相同的路径。

**简单路径**：除路径起点和终点相同外，其余顶点均不相同的路径

**简单回路（简单环）**：除路径起点和终点相同外，其余顶点均不相同的路径

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesi75mp5.png)

**连通图（强连通图）**：果对千图中任意两个顶点 V1， V,2 E V, V;1和 V2 都是连通的，则称 G 是连通图。

**连通分量**： 指的是无向图中的极大连通子图。

**生成**树：包含无向图G所有顶点的极小连通子图

**生成森林**：对非连通图，由各个连通分量的生成树的集合

### 图的存储结构

#### 数组（邻接矩阵）表示法

**无向图的邻接矩阵表示法**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesil98pn.png)

**有向图的邻接矩阵表示法**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesin9jfe.png)

**网的邻接矩阵表示法**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesio6fk7.png)

##### 邻接矩阵的建立

**存储结构**

```
//-----图的邻接矩阵存储表示－－－－－
#define Maxint 32767／／表示极大值， 即 OO
#define MVNum 100 ／／最大顶点数
typedef char VerTexType;／／假设顶点的数据类型为字符型
typedef int ArcType;／／假设边的权值类型为整型

typedef struct
{ 
VerTexType vexs [MVNum] ; ／／顶点表
ArcType arcs[MVNum] [MVNum]; ／／邻接矩阵
int vexnum,arcnum; ／／图的当前点数和边数
} AMGraph; 
```

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageslsdx9r.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageslszzyh.png)

##### 邻接矩阵的优缺点

**优点：**

便于判断两个顶点之间是否有边， 即根据A[i] [j] = 0或1来判断

便于计算各个顶点的度。

**缺点：**

不便于增加和删除顶点、

不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2）;

邻接矩阵表示法的空间复杂度为O(n*n)、

不适合存储稀疏图

#### 邻接表表示法

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesm1dwgm.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesngwhwv.png)

**无向图**

特点：邻接表不唯一、若有n个结点，e条边，则其邻接表需要n个头结点和2e个表结点，适宜存储稀疏图。存储空间为O(n+2e)、顶点Vi的度为第i个单链表中的结点数

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesm32ewr.png)

**有向图**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesm8hk4t.png)

##### 邻接表的建立

```
//- - - - -图的邻接表存储表示－ －－－－
#define MVNum 100／／最大顶点数

typedef struct ArcNode／／边结点
{
int adjvex; 			//该边所指向的顶点的位置
struct ArcNode * nextarc; ／／指向下一条边的指针
Otherinfo info; ／／和边相关的信息
}ArcNode; 

typedef struct VNode ／／顶点信息
{
VerTexType data; 
ArcNode *firstarc; ／／指向第一条依附该顶点的边的指针
} VNode,AdjList[MVNum]; //AdjList表示邻接表类型

typedef struct 		／／邻接表
{
AdjList vertices; 	
int vexnum,arcnum; ／／图的当前顶点数和边数
}ALGraph; 
```

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesmh7ost.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesn6ws49.png)

##### 邻接表的优缺点

**优点：**

便于增加和删除顶点。

便千统计边的数目， 按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为 O(n + e) 。

空间效率高。邻接表或逆邻接表表示的空间复杂度为 O(n + e)

适合表示稀疏图

**缺点：**

不便于判断顶点之间是否有边，最坏情况下要耗费 O(n)时间。

不便于计算有向图各个顶点的度

#### 邻接矩阵与邻接表的关系

**联系：**

邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数

**区别：**

对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链表次序与顶点编号无关）

邻接矩阵的空间复杂度为O(n^2),而邻接表的空间复杂度为O(n+e)

**用途：**

邻接矩阵多用于稠密图

邻接表多用于稀疏图

#### 十字链表

是**有向图**的另一种链式存储结构

**弧结点**：

尾域 (tailvex) 和头域 (headvex) 分别指示弧尾和弧头这两个顶点在 图中的位置

链域hlink 指向弧头相同的下一条弧，而链域 tlink 指向弧尾相同的下一条弧

info域指 向该弧的相关信息。

**头结点**：

firstin 和 firstout 为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesnlvhgt.png)

#### 邻接多重表

是**无向图**的另一种链式存储结构

**边结点**：

mark 为标志域，可用以标记该条边是否被搜索过； 

 ivex 和 jvex 为该边依附的两个顶点在表头数组中的位置；

ilink 指向下一条依附于顶点 ivex 的边

 jlink 指向下一条依附于顶点jvex的边

info为指向和边相关的各种信息的指针域

**顶点结点**：

data域存储和 该顶点相关的信息

firstedge域指示第一条依附于该顶点的边

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesnqio79.png)

### 图的遍历

**避免重复访问**

设置辅助数组 visited[n]，用来标记每个被访问过的顶点；初始状态 visited[i]=0，被访问后修改visited[i]=1，防止被多次访问

无论是DFS还是BFS，空间复杂度都相同，为O(n)

#### 深度优先搜索（DFS）

1、从某个顶点出发，访问该顶点

2、访问该顶点的第一个没有被访问的邻接点，访问该顶点；以该顶点为新的顶点，重复此步骤，直到刚访问过的顶点没有未被访问的邻接点为止。

3、返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的 邻接点， 访问该顶点

4、重复步骤 (2) 和(3), 直至图中所有顶点都被访问过，搜索结束

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesx8uq6u.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesx91lqq.png)

v1->v2->v->v4->v8->v5->v3->v6->v7

##### 邻接矩阵表示的无向图的深度遍历

时间复杂度为O(n*n),

稠密图适合在邻接矩阵上进行深度遍历

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesxebcwg.png)

##### 邻接表上的深度遍历

时间复杂度为O(n+e)

稀疏图适合在邻接表上进行深度遍历



#### 广度优先搜索（BFS）

从图的某个结点出发，首先依次访问该结点的所有邻接顶点，在按照这些顶点被访问的先后依次访问与它们相邻接的所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止

使用邻接矩阵存储时，时间复杂度为O(n*n)

使用邻接表存储时，时间复杂度为O(n+e)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesxnuaq7.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesxoilu6.png)

依次检查u的所有邻接点w, FirstAdjVex(G,u)表示u的第一个邻接点 

NextAdjVex(G,u,w)表示u相对于w的下一个邻接点，w>=0表示存在邻接点

### 最小生成树

 在一个连通网的所有生成树中，各边的权值之和最小的那棵生成树称 为该连通网的最小代价生成树,简称为最小生成树。

生成树：所有顶点均连接在一起，但不存在回路的图

#### MST性质

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesyrnd52.png)

#### 普里姆 (Prim) 算法

选择点

每次选择最小边时， 可能存在多条同样权值的边可选， 此时任选其一即可

时间复杂度为O(n*n)

适应于稠密图

![](https://raw.githubusercontent.com/195sjin/myBed/master/images1270doq.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/images127n7gg.png)

#### 克鲁斯卡尔 (Kruskal) 算法

选择边

切记不能有环，最小生成树可能不唯一

时间复杂度为O(eloge) e为边数

适应于稀疏图

![](https://raw.githubusercontent.com/195sjin/myBed/master/images12989cy.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/images129qy55.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/images129wt1j.png)

### 最短路径

在带权有向网中，习惯上称 路径上的第一个顶点为源点(Source), 最后一个顶点为终点(Destination)。

从源点到终点的多条路径中，寻找一条各边权值之和最小的路径，即最短路径，路径上不一定要包含n个顶点，也不一定包含n-1条边

#### 某源点到其他各点的最短路径

##### Dijkstra（迪杰斯特拉）算法

![](https://raw.githubusercontent.com/195sjin/myBed/master/images12nmwif.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/images12os86k.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/images12p6quu.png)

#### 任意一对两点之间最短路径

每次以一个顶点为源点，重复执行Dijkstra算法n次

##### Floyd（弗洛伊德）算法

![](https://raw.githubusercontent.com/195sjin/myBed/master/images12sh18p.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/images12t1kvd.png)

### 拓扑排序

**有向无环图**：无环的有向图，简称GAG图

AOV网：用一个有向图表示一个工程的各子工程及其相互制约的关系。以**顶点表示活动**，**弧表示**活动之间的优先制约关系，称这种有向图为顶点表示活动的网

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesttkfpf.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagestw1qma.png)

拓扑排序的应用：

检测AOV网中是否存在环；对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。

### 关键路径

AOE网：以弧表示活动，以顶点表示活动的开始或结束事件，弧的权表示活动持续时间，称这种有向图为边表示活动的网。

关键路径----------->路径长度最长的路径

路径长度----------->路径上各活动持续时间之和

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesu3sbwj.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesu5nllr.png)

**ve（j）是最大值    vl（j）是最小值**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvn6xz6.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvr4ujo.png)

关键活动就是a1->a4->a7->a8->a10->a11

## 六、查找

### 线性表的查找

#### 顺序查找法

**时间复杂度O(n),空间复杂度O(1)**

**平均查找长度为（n+1）/2**

从最后一个元素开始比较，把所要查找的元素赋值给顺序表中的零号位置，则0号位置起到了哨兵作用，，只需要从后往前查找，每一次循环只需要进行一次比较

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesh4xxk9.png)

比较次数与key的位置有关：查找第i个元素，需要比较n-i+1次，查找失败，需要比较n+1次

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesh816s5.png)

**顺序查找的特点：**

算法简单、逻辑次序无要求，适用于不同的存储结构

缺点：平均查找长度较大，查找效率低，当n很大时，不宜采用

#### 折半查找法

**时间复杂度为O(longn)**

**线性表必须采用顺序存储结构，并且表中元素有序排列，基本都是递增有序排列**

用low和high来表示当前查找区间的下界和 上界，mid为区间的中间位置

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesi7pr1d.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageshddbej.png)

**算法分析**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageshgeylw.png)

**优点：**

效率比顺序查找高

**缺点：**

只适用于有序表，且仅限于顺序存储结构（对线性链表无效）

#### 分块查找法

每一块里面的元素排列可以是有序的，也可以是无序的

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesia2ekj.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesibqip5.png)

优点：

插入删除比较容易，无需进行大量移动

缺点：

要增加一个索引表的存储空间并对初始索引表进行排序运算



如果线性表既要快速查找又要经常动态变化，则可以使用分块查找

#### 三种顺序查找的比较

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesidkfcl.png)



### 树表的查找

#### 二叉排序树

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树： 

(I) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 

(2) 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 

(3) 它的左、 右子树也分别为二叉排序树。

二叉排序树是递归定义的。 由定义可以得出二叉排序树的一个重要性质：**中序遍历**一棵二叉 树时可以得到一个结点值**递增的有序序列。**

##### 二叉排序树的查找

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesik5gvx.png)

**分析**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesilwgab.png)



##### 二叉排序树的插入和生成

生成：

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagess525e6.png)

插入：

不同插入次序的序列生成不同形态的二叉排序树



##### 二叉排序树的删除

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagess8lzqw.png)



#### 平衡二叉树

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagess9rk0r.png)

**平衡因子=结点左子树的高度-结点右子树的高度，平衡因子只能是 -1、0、1**

平衡二叉树的高度保持在O(logn)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessdcdb5.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesse9yih.png)

LL型：

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesshy9yu.png)

RR型：

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesshjqua.png)

LR型：

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessinaju.png)

**RR型与LR型类似**



### 散列表的查找

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessopdbk.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagestuoysd.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagestuwen4.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagestvcok1.png)

#### 散列函数

选取该函数，依该函数按关键字计算元素的存储位置，并按此存放

(1)函数计算要简单，每一关键字只能有一个散列地址与之对应； 

(2) 函数的值域需在表长的范围内， 计算出的散列地址的分布应均匀，尽可能减少冲突。

##### 直接定址法

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesst8h42.png)

##### 除留余数法

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessuck94.png)

#### 冲突

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessqvqtr.png)

**解决冲突**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessyrjt8.png)

##### 开放定址法

有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入

###### 线性探测法

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessyk11h.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagessy057n.png)

###### 二次探测法

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagest0au6k.png)

伪随机探测法

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagest11mp0.png)

##### 链地址法

优点：

非同义词不会冲突，无“聚集”现象、链表上结点空间动态申请，更适合于表长不确定的情况

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagest3lujj.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagestryg86.png)



## 七、排序

### 插入排序

每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序 的一组记录的适当位置上，直到所有待排序记录全部插入为止。

#### 直接插入排序

采用**顺序查找法**查找插入位置

从第i个元素无序

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesu5kg7c.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesu62bfv.png)



#### 折半插入排序

查找插入位置时采用折半查找法

减少了比较次数，但是没有减少移动次数

时间复杂度为O(n*n),空间复杂度为O(1)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesu93f38.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesuaadb8.png)



#### 希尔排序

先将整个待排序记录序列**分割成几组**，对每组分别进行**直接插入排序**， 这样当经过几次分组排序后，整个序列中的记录 “**基本有序**” 时，再对全体记录进行一次直接插入排序

一次移动，移动位置较大，跳跃式地接近排序后的最终位置

最后一次只需要少量移动

增量序列必须是递减的，最后一个必须是1

增量序列应该是互质的

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesuih3vj.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesudfu72.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/images8gbud7y.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesugs23h.png)



### 交换排序

两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求 时则进行交换，直到整个序列全部满足要求为止

#### 冒泡排序

两两比较相邻记录的关键字， 如果发生逆序，则进行交换，从而使关键字小的记录如气泡一般逐渐往上 ＂漂浮＂ （左移），或者使关键字大的记录如石块一样逐渐向下 ＂坠落” （右移）。

一共有n个元素，则需要比较n-1趟，第m趟，每一趟需要比较n-m次

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesunumhc.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesuoih9d.png)



#### 快速排序

**快速排序不适宜对原本有序或者基本有序的记录序列进行排序**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvru2kj.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvpyje0.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/images8tdj8fe.png)



![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesupt77y.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesur05mq.png)



![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvkqmwc.png)



![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvkwx0v.png)



### 选择排序

#### 简单选择排序

在待排序的数据中选出最大（小）的元素放在其最终的位置

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvv10z1.png)



![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvvkg9j.png)



#### 堆排序

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesw0ugrv.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvx8yt2.png)

**第i个元素，它的左孩子就是2i，右孩子就是2i+1**

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesvz2ksq.png)

##### 堆调整

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesw2nwuk.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesw3uo9j.png)

##### 堆的建立

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesw82yv3.png)

##### 堆排序算法

时间复杂度为O(nlogn)

空间复杂度为O(1)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesw97ct6.png)



### 归并排序

将两个或两个以上的有序表合并成一个有序表的过程。将两个 有序表合并成一个有序表的过程称为2-路归并

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageswbkkho.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageswctq0f.png)



### 基数排序

![](https://raw.githubusercontent.com/195sjin/myBed/master/imageswenb58.png)

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesx49cuw.png)



### 排序的对比

![](https://raw.githubusercontent.com/195sjin/myBed/master/imagesx5tdnz.png)
